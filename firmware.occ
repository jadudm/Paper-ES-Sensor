#INCLUDE "plumbing.module"
#INCLUDE "eeprom.24LC256.module"
#INCLUDE "twi3.module"
#INCLUDE "pir.module"
#INCLUDE "chronodot.module"

VAL INT TEMP.SENSOR.PIN IS A1:
VAL INT LIGHT.SENSOR.PIN IS A0:

VAL BYTE INIT.READING   IS 'I':
VAL BYTE CLOCK.READING  IS 'C':
VAL BYTE MOTION.READING IS 'M':

DATA TYPE READING
  RECORD
    BYTE hours:
    BYTE minutes:
    BYTE type:
    INT  temp:
    INT  light:
:

PROTOCOL TIME IS BYTE ; BYTE:

PROC serial.write.dec.int (VAL INT port, VAL INT n)
  INITIAL INT index IS 0:
  INITIAL INT number IS n:
  INITIAL BOOL neg IS FALSE:
  SEQ
    IF
      n < 0
        SEQ
          neg := TRUE
          number := n * (- 1)
      TRUE
        SKIP
    IF 
      neg 
        serial.write.string (port, "-")
      TRUE 
        SKIP
    INITIAL BOOL LEADING IS TRUE:
    WHILE (index < 5)
      INT digit:
      SEQ
        digit := number / dec.powers[index]
        number := number REM dec.powers[index]
        IF
          LEADING AND (digit = 0)
            SKIP 
          (digit <> 0) OR (NOT LEADING) 
            SEQ
              LEADING := FALSE
              digit := digit + (INT '0')
              serial.write.byte(port, (BYTE digit))
        index := index + 1
:

PROC serial.write.time (VAL INT port, VAL [3]INT hms)
  SEQ i = 0 FOR 3
    SEQ
      IF
        hms[i] = 0
          serial.write.string (port, "00")
        hms[i] < 10
          serial.write.string (port, "0")
        TRUE
          SKIP
      serial.write.dec.int (port, hms[i])
      IF
        i <> 2
          serial.write.string (port, ":")
        TRUE
          SKIP
:

PROC bogo.clock (CHAN SIGNAL tick!, CHAN TIME hm!)
  [3]INT hms:
  WHILE TRUE
    SEQ
      delay (2000)
      chronodot.get.time(hms)
      #PRAGMA DEFINED hms
      hm ! (BYTE hms[0]) ; (BYTE hms[1])
      tick ! SIGNAL
:

PROC current.time (CHAN SIGNAL req?, CHAN TIME update?, recent!)
  INITIAL BOOL READY IS FALSE:
  INITIAL BYTE hours, minutes IS 0, 0:
  WHILE TRUE
    ALT
      update ? hours ; minutes
        SKIP  
      -- On the first read, make sure we wait.
      NOT READY & req ? SIGNAL
        SEQ
          update ? hours ; minutes
          recent ! hours ; minutes
          READY := TRUE
      req ? SIGNAL
        recent ! hours ; minutes 
:
 
PROC signal.delta (CHAN SIGNAL in?, o1!, o2!)
  WHILE TRUE
    SEQ
      in ? SIGNAL
      PAR
        o1 ! SIGNAL
        o2 ! SIGNAL
:

--{{{ PROC n.minute.ticker (VAL INT minutes, CHAN SIGNAL in?, out!)
-- Expects a SIGNAL on the channel 'in' every minute.
-- Generates a SIGNAL on the channel 'out' every 'num.minutes'.
PROC n.minute.ticker (VAL INT num.minutes, CHAN SIGNAL in?, out!)
  INITIAL INT counter IS num.minutes:
  WHILE TRUE
    SEQ
      in ? SIGNAL
      counter := counter - 1
      IF
        counter <> 0
          SKIP
        TRUE
          SEQ
            out ! SIGNAL
            counter := num.minutes
:

--{{{ PROC motion (SIGNAL s!)
-- Monitors the Modern Device PIR sensor.
-- Pin 5 is used to power the sensor.
-- Pin 2 is used to monitor the sensor.
-- A signal is generated on the channel 's'
-- whenever motion is detected.
PROC motion (CHAN SIGNAL s!)
  pir (5, 2, s!)
:
--}}}

PROC motion.throttle (CHAN SIGNAL motion?, reset?, out!)
  INITIAL BOOL IGNORING IS FALSE:
  WHILE TRUE
    ALT
      -- When the reset line fires, we can stop ignoring
      -- the motion sensor.
      reset ? SIGNAL
        IGNORING := FALSE
      -- If we are not ignoring the motion sensor, we should
      -- pass on the message that it fired, and then start
      -- ignoring it until the next reset comes in.
      NOT IGNORING & motion ? SIGNAL
        SEQ
          out ! SIGNAL
          IGNORING := TRUE
      -- We must be ignoring the motion sensor, so read in the 
      -- SIGNAL and then do nothing.
      IGNORING & motion ? SIGNAL
        SKIP
:

PROC light.sensor (CHAN SIGNAL req?, CHAN INT resp!)
  adc (LIGHT.SENSOR.PIN, VCC, req?, resp!)
:

-- Output should end up in degrees C, and therefore
-- always within the range of a BYTE.
PROC convert.temp (CHAN INT in?, CHAN INT out!)
  WHILE TRUE
    INT32 lv:
    INT v:
    SEQ
      in ? v
      lv := (INT32 v)
      lv := (lv * 250) / 1024
      out ! (INT lv)
:

--}}}

PROC temp.sensor (CHAN SIGNAL req?, CHAN INT resp!)
  CHAN INT raw:
  PAR
    adc (TEMP.SENSOR.PIN, VCC, req?, raw!)
    convert.temp (raw?, resp!)
: 

PROC init.reading (CHAN SIGNAL s!)
  s ! SIGNAL
:

-- Generate initial packets continuously.
PROC init.packet (CHAN READING out!)
  WHILE TRUE
    READING r:
    SEQ
      r[hours]   := 0
      r[minutes] := 0
      r[type]    := 'X'
      r[light]   := 0
      r[temp]    := 0
      out ! r
:

PROC get.type (CHAN READING data.in?, data.out!,
               CHAN SIGNAL init?, motion?, clock?)
  WHILE TRUE
    READING r:
    SEQ
      -- Grab the packet
      data.in ? r
      -- Who asked for a reading?
      ALT
        init ? SIGNAL
          r[type] := INIT.READING
        motion ? SIGNAL
          r[type] := MOTION.READING
        clock ? SIGNAL
          r[type] := CLOCK.READING
      data.out ! r
:

PROC get.time (CHAN READING data.in?, data.out!,
               CHAN SIGNAL time.req!, CHAN TIME time.resp?)
  WHILE TRUE
    READING r:
    SEQ
      data.in ? r
      time.req ! SIGNAL
      time.resp ? r[hours] ; r[minutes]
      data.out ! r
:

PROC get.data (CHAN READING data.in?, data.out!)
  CHAN SIGNAL light.req, temp.req:
  CHAN INT light.resp, temp.resp:
  PAR
    light.sensor (light.req?, light.resp!)
    temp.sensor (temp.req?, temp.resp!)
    WHILE TRUE
      READING r:
      SEQ
        data.in ? r
        -- Get the light level
        light.req ! SIGNAL
        light.resp ? r[light]
        -- Get the temperature
        temp.req  ! SIGNAL
        temp.resp  ? r[temp]
        -- Send the data out
        data.out ! r
:

PROC display (CHAN READING data?)
  WHILE TRUE
    READING r:
    SEQ
      data ? r
      serial.write.time   (TX0, [(INT r[hours]), (INT r[minutes]), 0])
      serial.write.string (TX0, [r[type]])
      serial.write.string (TX0, ": L[")
      serial.write.int    (TX0, r[light])
      serial.write.string (TX0, "] T[")
      serial.write.int    (TX0, r[temp])
      serial.write.string (TX0, "]*n")
:

PROC main ()
  CHAN SIGNAL tick, motion.tick, clock.tick, time.req:
  CHAN SIGNAL read.init, read.clock:
  CHAN SIGNAL movement, motion.ok, read.movement:
  CHAN READING a, b, c, d:
  CHAN TIME hms, time.resp:
  PAR
    bogo.clock (tick!, hms!) 
    current.time (time.req?, hms?, time.resp!)

    init.packet (a!)
    get.type (a?, b!, read.init?, read.movement?, read.clock?)
    get.time (b?, c!, time.req!, time.resp?)
    get.data (c?, d!)

    signal.delta (tick?, motion.tick!, clock.tick!)
    n.minute.ticker (5, motion.tick?, motion.ok!)
    n.minute.ticker (10, clock.tick?, read.clock!)
    
    init.reading (read.init!)
    
    motion (movement!)
    motion.throttle (movement?, motion.ok?, read.movement!)
    
    display (d?)
    
:
