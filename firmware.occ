#INCLUDE "plumbing.module"
#INCLUDE "eeprom.24LC256.module"
#INCLUDE "twi3.module"
#INCLUDE "pir.module"
#INCLUDE "chronodot.module"

VAL INT TEMP.SENSOR.PIN IS A1:
VAL INT LIGHT.SENSOR.PIN IS A0:
VAL INT PIR.POWER IS 5:
VAL INT PIR.SENSE IS 2:

VAL BYTE INIT.READING   IS 'I':
VAL BYTE CLOCK.READING  IS 'C':
VAL BYTE MOTION.READING IS 'M':

VAL INT LOG.TX IS TX0:
VAL INT LOG.PORT IS 0:

DATA TYPE READING
  RECORD
    BYTE hours:
    BYTE minutes:
    BYTE type:
    INT  temp:
    INT  light:
:

PROTOCOL TIME IS BYTE ; BYTE:

PROC serial.write.dec.int (VAL INT port, VAL INT n)
  INITIAL INT index IS 0:
  INITIAL INT number IS n:
  INITIAL BOOL neg IS FALSE:
  IF
    n = 0
      serial.write.string (port, "0")
    TRUE
      SEQ
        IF
          n < 0
            SEQ
              neg := TRUE
              number := n * (- 1)
          TRUE
            SKIP
        IF 
          neg 
            serial.write.string (port, "-")
          TRUE 
            SKIP
        INITIAL BOOL LEADING IS TRUE:
        WHILE (index < 5)
          INT digit:
          SEQ
            digit := number / dec.powers[index]
            number := number REM dec.powers[index]
            IF
              LEADING AND (digit = 0)
                SKIP 
              (digit <> 0) OR (NOT LEADING) 
                SEQ
                  LEADING := FALSE
                  digit := digit + (INT '0')
                  serial.write.byte(port, (BYTE digit))
            index := index + 1
:

PROC bogo.clock (CHAN SIGNAL tick!, CHAN TIME hm!)
  [3]INT hms:
  WHILE TRUE
    SEQ
      delay (500)
      chronodot.get.time(hms)
      #PRAGMA DEFINED hms
      hm ! (BYTE hms[0]) ; (BYTE hms[1])
      tick ! SIGNAL
:

PROC real.clock (CHAN SIGNAL tick!, CHAN TIME hm!)
  [3]INT hms:
  #PRAGMA DEFINED hms
  CHAN SIGNAL tock:
  CHAN LEVEL intr:
  PAR
    digital.input (3, intr!)
    level.to.signal (intr?, tock!)
    WHILE TRUE
      SEQ
        tock ? SIGNAL
        chronodot.get.time (hms)
        hm ! (BYTE hms[0]) ; (BYTE hms[1])
        tick ! SIGNAL
:

PROC current.time (CHAN SIGNAL req?, CHAN TIME update?, recent!)
  INITIAL BOOL READY IS FALSE:
  INITIAL BYTE hours, minutes IS 0, 0:
  WHILE TRUE
    ALT
      update ? hours ; minutes
        SKIP  
      -- On the first read, make sure we wait.
      NOT READY & req ? SIGNAL
        SEQ
          update ? hours ; minutes
          recent ! hours ; minutes
          READY := TRUE
      req ? SIGNAL
        recent ! hours ; minutes 
:
 
PROC signal.delta (CHAN SIGNAL in?, o1!, o2!)
  WHILE TRUE
    SEQ
      in ? SIGNAL
      PAR
        o1 ! SIGNAL
        o2 ! SIGNAL
:

--{{{ PROC n.minute.ticker (VAL INT minutes, CHAN SIGNAL in?, out!)
-- Expects a SIGNAL on the channel 'in' every minute.
-- Generates a SIGNAL on the channel 'out' every 'num.minutes'.
PROC n.minute.ticker (VAL INT num.minutes, CHAN SIGNAL in?, out!)
  INITIAL INT counter IS num.minutes:
  WHILE TRUE
    SEQ
      in ? SIGNAL
      counter := counter - 1
      IF
        counter <> 0
          SKIP
        TRUE
          SEQ
            out ! SIGNAL
            counter := num.minutes
:

--{{{ PROC motion (SIGNAL s!)
-- Monitors the Modern Device PIR sensor.
-- Pin 5 is used to power the sensor.
-- Pin 2 is used to monitor the sensor.
-- A signal is generated on the channel 's'
-- whenever motion is detected.
INLINE PROC motion (CHAN SIGNAL s!)
  pir (PIR.POWER, PIR.SENSE, s!)
:
--}}}

PROC motion.throttle (CHAN SIGNAL motion?, reset?, out!)
  INITIAL BOOL IGNORING IS FALSE:
  WHILE TRUE
    ALT
      -- When the reset line fires, we can stop ignoring
      -- the motion sensor.
      reset ? SIGNAL
        IGNORING := FALSE
      -- If we are not ignoring the motion sensor, we should
      -- pass on the message that it fired, and then start
      -- ignoring it until the next reset comes in.
      NOT IGNORING & motion ? SIGNAL
        SEQ
          out ! SIGNAL
          IGNORING := TRUE
      -- We must be ignoring the motion sensor, so read in the 
      -- SIGNAL and then do nothing.
      IGNORING & motion ? SIGNAL
        SKIP
:

PROC light.sensor (CHAN SIGNAL req?, CHAN INT resp!)
  adc (LIGHT.SENSOR.PIN, VCC, req?, resp!)
:

-- Output should end up in degrees C, and therefore
-- always within the range of a BYTE.
PROC convert.temp (CHAN INT in?, CHAN INT out!)
  WHILE TRUE
    INT32 lv:
    INT v:
    SEQ
      in ? v
      lv := (INT32 v)
      lv := (lv * 250) / 1024
      out ! (INT lv)
:

--}}}

PROC temp.sensor (CHAN SIGNAL req?, CHAN INT resp!)
  CHAN INT raw:
  PAR
    adc (TEMP.SENSOR.PIN, VCC, req?, raw!)
    convert.temp (raw?, resp!)
: 

PROC init.reading (CHAN SIGNAL s!)
  s ! SIGNAL
:

-- Generate initial packets continuously.
PROC init.packet (CHAN READING out!)
  WHILE TRUE
    READING r:
    SEQ
      r[hours]   := 0
      r[minutes] := 0
      r[type]    := 'X'
      r[light]   := 0
      r[temp]    := 0
      out ! r
      --serial.write.string (TX0, "init.packet*n")
:

PROC get.type (CHAN READING data.in?, data.out!,
               CHAN SIGNAL init?, motion?, clock?)
  WHILE TRUE
    READING r:
    SEQ
      -- Grab the packet
      data.in ? r
      -- Who asked for a reading?
      ALT
        init ? SIGNAL
          r[type] := INIT.READING
        motion ? SIGNAL
          r[type] := MOTION.READING
        clock ? SIGNAL
          r[type] := CLOCK.READING
      data.out ! r
      --serial.write.string (TX0, "get.type*n")
:

PROC get.time (CHAN READING data.in?, data.out!,
               CHAN SIGNAL time.req!, CHAN TIME time.resp?)
  WHILE TRUE
    READING r:
    SEQ
      data.in ? r
      time.req ! SIGNAL
      time.resp ? r[hours] ; r[minutes]
      data.out ! r
      --serial.write.string (TX0, "get.time*n")
:

PROC get.data (CHAN READING data.in?, data.out!)
  CHAN SIGNAL light.req, temp.req:
  CHAN INT light.resp, temp.resp:
  PAR
    light.sensor (light.req?, light.resp!)
    temp.sensor (temp.req?, temp.resp!)
    WHILE TRUE
      READING r:
      SEQ
        data.in ? r
        -- Get the light level
        light.req ! SIGNAL
        light.resp ? r[light]
        -- Get the temperature
        temp.req  ! SIGNAL
        temp.resp  ? r[temp]
        -- Send the data out
        data.out ! r
        --serial.write.string (TX0, "get.data*n")
:

PROC serial.write.comma (VAL INT port)
  serial.write.string (port, ",")
:

INLINE PROC serial.write.data.int (VAL INT port, VAL INT n)
  serial.write.int (port, n)
:

PROC display (CHAN READING data?)
  WHILE TRUE
    READING r:
    SEQ
      data ? r
      serial.write.int (LOG.TX, (INT r[hours]))
      serial.write.comma   (LOG.TX)
      serial.write.data.int (LOG.TX, (INT r[minutes]))
      serial.write.comma   (LOG.TX)
      serial.write.string  (LOG.TX, [r[type]])
      serial.write.comma   (LOG.TX)
      serial.write.data.int (LOG.TX, r[light])
      serial.write.comma   (LOG.TX)
      serial.write.data.int (LOG.TX, r[temp])
      serial.write.newline (LOG.TX)
      -- Tell the OpenLog to flush the buffer to the SD card.
      serial.write.byte    (LOG.TX, 26)
:

PROC main ()
  CHAN SIGNAL tick, motion.tick, clock.tick, time.req:
  CHAN SIGNAL read.init, read.clock:
  CHAN SIGNAL movement, motion.ok, read.movement:
  CHAN READING a, b, c, d:
  CHAN TIME hms, time.resp:
  SEQ
    pir.init (PIR.POWER, PIR.SENSE)
    serial.start (LOG.PORT, 9600)
    chronodot.write.many (#07, [#FF, #FF, #FF, #FF])
    -- Wait for the PIR to stabilize
    delay (5000)
    PAR
      --bogo.clock (tick!, hms!) 
      real.clock (tick!, hms!)
      current.time (time.req?, hms?, time.resp!)

      init.packet (a!)
      get.type (a?, b!, read.init?, read.movement?, read.clock?)
      get.time (b?, c!, time.req!, time.resp?)
      get.data (c?, d!)

      signal.delta (tick?, motion.tick!, clock.tick!)
      n.minute.ticker (2, motion.tick?, motion.ok!)
      n.minute.ticker (5, clock.tick?, read.clock!)
      
      init.reading (read.init!)
      --WHILE TRUE
      --  motion.ok ? SIGNAL 
      motion (movement!)
      motion.throttle (movement?, motion.ok?, read.movement!)
      
      display (d?)
    
:
