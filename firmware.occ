#INCLUDE "plumbing.module"
#INCLUDE "eeprom.24LC256.module"
#INCLUDE "twi3.module"
#INCLUDE "pir.module"
#INCLUDE "chronodot.module"

VAL INT TEMP.SENSOR.PIN IS A1:
VAL INT LIGHT.SENSOR.PIN IS A0:
VAL INT PIR.POWER IS 5:
VAL INT PIR.SENSE IS 2:

VAL BYTE INIT.READING   IS 'I':
VAL BYTE CLOCK.READING  IS 'C':
VAL BYTE MOTION.READING IS 'M':

VAL INT LOG.TX IS TX0:
VAL INT LOG.PORT IS 0:

VAL INT INIT.HOURS IS 15:
VAL INT INIT.MINUTES IS 45:

DATA TYPE READING
  RECORD
    BYTE hours:
    BYTE minutes:
    BYTE type:
    INT  temp:
    INT  light:
:

PROTOCOL TIME IS BYTE ; BYTE:

PROC bogo.clock (CHAN SIGNAL tick!, CHAN TIME hm!)
  [3]INT hms:
  WHILE TRUE
    SEQ
      delay (500)
      chronodot.get.time(hms)
      #PRAGMA DEFINED hms
      hm ! (BYTE hms[0]) ; (BYTE hms[1])
      tick ! SIGNAL
:

INLINE PROC clear.clock.flags ()
  -- Clear alarm flags
  chronodot.write (#0F, #00)
:

PROC setup.clock (VAL INT hrs, min)
  SEQ
    INITIAL [3]INT hms IS [hrs, min, 0]:
    chronodot.set.time (hms)
    -- Enable alarm interrupt
    chronodot.write (#0E, #1E)
    -- Clear alarm flags
    clear.clock.flags()
    -- Enable an alarm every second
    -- chronodot.write.many (#07, [#80, #80, #80, #80])
    -- Every minute
    chronodot.write.many (#0B, [#80, #80, #80])
:

PROC real.clock (CHAN SIGNAL tick!, CHAN TIME hm!)
  [3]INT hms:
  #PRAGMA DEFINED hms
  CHAN SIGNAL tock:
  CHAN LEVEL intr:
  SEQ
    -- Send out an initial tick
    chronodot.get.time (hms)
    hm ! (BYTE hms[0]) ; (BYTE hms[1])
    PAR
      digital.input (3, intr!)
      level.to.signal (intr?, tock!)
      WHILE TRUE
        SEQ
          digital.write (13, HIGH)
          clear.clock.flags()
          tock ? SIGNAL
          clear.clock.flags()
          digital.write (13, LOW)
          chronodot.get.time (hms)
          hm ! (BYTE hms[0]) ; (BYTE hms[1])
          tick ! SIGNAL
:

PROC current.time (CHAN SIGNAL req?, CHAN TIME update?, recent!)
  INITIAL BOOL READY IS FALSE:
  INITIAL BYTE hours, minutes IS 0, 0:
  WHILE TRUE
    ALT
      update ? hours ; minutes
        -- Any time we get an update, we're ready.
        -- This matters if we're kickstarting the process.
        READY := TRUE  
      -- On the first read, make sure we wait.
      NOT READY & req ? SIGNAL
        SEQ
          update ? hours ; minutes
          recent ! hours ; minutes
          READY := TRUE
      req ? SIGNAL
        recent ! hours ; minutes 
:
 
PROC signal.delta (CHAN SIGNAL in?, o1!, o2!)
  WHILE TRUE
    SEQ
      in ? SIGNAL
      PAR
        o1 ! SIGNAL
        o2 ! SIGNAL
:

--{{{ PROC n.minute.ticker (VAL INT minutes, CHAN SIGNAL in?, out!)
-- Expects a SIGNAL on the channel 'in' every minute.
-- Generates a SIGNAL on the channel 'out' every 'num.minutes'.
PROC n.minute.ticker (VAL INT num.minutes, CHAN SIGNAL in?, out!)
  INITIAL INT counter IS num.minutes:
  WHILE TRUE
    SEQ
      in ? SIGNAL
      counter := counter - 1
      IF
        counter <> 0
          SKIP
        TRUE
          SEQ
            out ! SIGNAL
            counter := num.minutes
:

--{{{ PROC motion (SIGNAL s!)
-- Monitors the Modern Device PIR sensor.
-- Pin 5 is used to power the sensor.
-- Pin 2 is used to monitor the sensor.
-- A signal is generated on the channel 's'
-- whenever motion is detected.
INLINE PROC motion (CHAN SIGNAL s!)
  pir (PIR.POWER, PIR.SENSE, s!)
:
--}}}

PROC motion.throttle (CHAN SIGNAL motion?, reset?, out!)
  INITIAL BOOL IGNORING IS FALSE:
  WHILE TRUE
    ALT
      -- When the reset line fires, we can stop ignoring
      -- the motion sensor.
      reset ? SIGNAL
        IGNORING := FALSE
      -- If we are not ignoring the motion sensor, we should
      -- pass on the message that it fired, and then start
      -- ignoring it until the next reset comes in.
      NOT IGNORING & motion ? SIGNAL
        SEQ
          out ! SIGNAL
          IGNORING := TRUE
      -- We must be ignoring the motion sensor, so read in the 
      -- SIGNAL and then do nothing.
      IGNORING & motion ? SIGNAL
        SKIP
:

PROC light.sensor (CHAN SIGNAL req?, CHAN INT resp!)
  adc (LIGHT.SENSOR.PIN, VCC, req?, resp!)
:

-- Output should end up in degrees C, and therefore
-- always within the range of a BYTE.
PROC convert.temp (CHAN INT in?, CHAN INT out!)
  WHILE TRUE
    INT32 lv:
    INT v:
    SEQ
      in ? v
      lv := (INT32 v)
      lv := (lv * 250) / 1024
      out ! (INT lv)
:

--}}}

PROC temp.sensor (CHAN SIGNAL req?, CHAN INT resp!)
  CHAN INT raw:
  PAR
    adc (TEMP.SENSOR.PIN, VCC, req?, raw!)
    convert.temp (raw?, resp!)
: 

INLINE PROC trigger.initial.reading (CHAN SIGNAL s!)
  s ! SIGNAL
:

-- Generate initial packets continuously.
PROC init.packet (CHAN READING out!)
  WHILE TRUE
    READING r:
    SEQ
      r[hours]   := 0
      r[minutes] := 0
      r[type]    := 'X'
      r[light]   := 0
      r[temp]    := 0
      digital.write (12, HIGH)
      out ! r
      digital.write (12, LOW)
      --serial.write.string (TX0, "init.packet*n")
:

PROC get.type (CHAN READING data.in?, data.out!,
               CHAN SIGNAL init?, motion?, clock?)
  WHILE TRUE
    READING r:
    SEQ
      -- Grab the packet
      data.in ? r
      digital.write (11, HIGH)
      -- Who asked for a reading?
      ALT
        init ? SIGNAL
          r[type] := INIT.READING
        motion ? SIGNAL
          r[type] := MOTION.READING
        clock ? SIGNAL
          r[type] := CLOCK.READING
      data.out ! r
      digital.write (11, LOW)
      --serial.write.string (TX0, "get.type*n")
:

PROC get.time (CHAN READING data.in?, data.out!,
               CHAN SIGNAL time.req!, CHAN TIME time.resp?)
  WHILE TRUE
    READING r:
    SEQ
      data.in ? r
      digital.write (10, HIGH)
      time.req ! SIGNAL
      time.resp ? r[hours] ; r[minutes]
      data.out ! r
      digital.write (10, LOW)
      --serial.write.string (TX0, "get.time*n")
:

PROC get.data (CHAN READING data.in?, data.out!)
  CHAN SIGNAL light.req, temp.req:
  CHAN INT light.resp, temp.resp:
  PAR
    light.sensor (light.req?, light.resp!)
    temp.sensor (temp.req?, temp.resp!)
    WHILE TRUE
      READING r:
      SEQ
        data.in ? r
        digital.write (9, HIGH)
        -- Get the light level
        light.req ! SIGNAL
        light.resp ? r[light]
        -- Get the temperature
        temp.req  ! SIGNAL
        temp.resp  ? r[temp]
        -- Send the data out
        data.out ! r
        digital.write (9, LOW)
        --serial.write.string (TX0, "get.data*n")
:

PROC serial.write.comma (VAL INT port)
  serial.write.byte (port, ',')
:

INLINE PROC serial.write.data.int (VAL INT port, VAL INT n)
  serial.write.int (port, n)
:

PROC display (CHAN READING data?)
  WHILE TRUE
    READING r:
    SEQ
      data ? r
      serial.write.data.int (LOG.TX, (INT r[hours]))
      serial.write.comma    (LOG.TX)
      serial.write.data.int (LOG.TX, (INT r[minutes]))
      serial.write.comma    (LOG.TX)
      serial.write.string   (LOG.TX, [r[type]])
      serial.write.comma    (LOG.TX)
      serial.write.data.int (LOG.TX, r[light])
      serial.write.comma    (LOG.TX)
      serial.write.data.int (LOG.TX, r[temp])
      serial.write.newline  (LOG.TX)
      -- Tell the OpenLog to flush the buffer to the SD card.
      -- serial.write.byte     (LOG.TX, 26)
:

PROC main ()
  CHAN SIGNAL tick, motion.tick, clock.tick, time.req:
  CHAN SIGNAL read.init, read.clock:
  CHAN SIGNAL movement, motion.ok, read.movement:
  CHAN READING a, b, c, d:
  CHAN TIME hms, time.resp:
  SEQ
    SEQ i = 0 FOR 4
      digital.mode (9 + i, OUTPUT)
    digital.write (13, HIGH)
    pir.init (PIR.POWER, PIR.SENSE)
    serial.start (LOG.PORT, 57600)
    serial.write.byte (TX0, '*n')
    setup.clock (INIT.HOURS, INIT.MINUTES)
    -- Wait for the PIR to stabilize
    delay (5000)
    digital.write (13, LOW)
    PAR
      --bogo.clock (tick!, hms!) 
      real.clock (tick!, hms!)
      current.time (time.req?, hms?, time.resp!)

      init.packet (a!)
      get.type (a?, b!, read.init?, read.movement?, read.clock?)
      get.time (b?, c!, time.req!, time.resp?)
      -- get.data (c?, d!)

      signal.delta (tick?, motion.tick!, clock.tick!)
      n.minute.ticker (1, motion.tick?, motion.ok!)
      n.minute.ticker (1, clock.tick?, read.clock!)
      
      trigger.initial.reading (read.init!)
      WHILE TRUE
        motion.ok ? SIGNAL 
      -- motion (movement!)
      -- motion.throttle (movement?, motion.ok?, read.movement!)
      
      display (c?)
:
