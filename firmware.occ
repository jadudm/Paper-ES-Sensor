#INCLUDE "plumbing.module"
#INCLUDE "eeprom.24LC256.module"
#INCLUDE "twi2.module"


PROC status ()
  BYTE status:
  SEQ
    get.twi.status(status)
    serial.write.string(TX0, "[s] ")
    serial.write.int(TX0, INT status)
    serial.write.string(TX0, "*n")
:

VAL INT BYTE.ADDR IS 0:
VAL INT WORD.ADDR IS 1:
PROC twi.write.byte (VAL BYTE dev, VAL INT addr.size, VAL INT addr, VAL BYTE b)
  SEQ
    twi.init() 
    twi.start()
    twi.set.tx.addr((dev << 1))
    IF
      addr.size = BYTE.ADDR
        twi.tx(BYTE addr)
      addr.size = WORD.ADDR
        SEQ
          twi.tx((BYTE (addr >> 8)))
          twi.tx((BYTE (addr BITAND #FF)))
      TRUE
        SKIP

    twi.tx(b)
    twi.stop()
:    

INLINE PROC clock.write (VAL INT addr, VAL BYTE b)
  twi.write.byte(#68, BYTE.ADDR, addr, b)
:

INLINE PROC eeprom.write (VAL INT addr, VAL BYTE b)
  twi.write.byte(#50, WORD.ADDR, addr, b)
:

PROC twi.read (VAL BYTE dev, VAL INT addr.size, VAL INT addr, RESULT BYTE b)
  SEQ
    twi.init()
    twi.start()
    twi.set.tx.addr((dev << 1))
    IF
      addr.size = BYTE.ADDR
        twi.tx(BYTE addr)
      addr.size = WORD.ADDR
        SEQ
          twi.tx((BYTE (addr >> 8)))
          twi.tx((BYTE (addr BITAND #FF)))
      TRUE
        SKIP
    twi.start()
    twi.set.rx.addr((dev << 1) \/ 1)
    twi.read.byte(TWI.NACK, b)
    twi.stop()
:

INLINE PROC clock.read (VAL INT addr, RESULT BYTE b)
  twi.read (#68, BYTE.ADDR, addr, b)
:

INLINE PROC eeprom.read (VAL INT addr, RESULT BYTE b)
  twi.read (#50, WORD.ADDR, addr, b)
:

PROC twi.read.many (VAL BYTE dev, VAL INT addr.size, VAL INT addr, RESULT []BYTE bs)
  SEQ
    twi.init()
    twi.start()
    twi.set.tx.addr((dev << 1))
    IF
      addr.size = BYTE.ADDR
        twi.tx(BYTE addr)
      addr.size = WORD.ADDR
        SEQ
          twi.tx((BYTE (addr >> 8)))
          twi.tx((BYTE (addr BITAND #FF)))
      TRUE
        SKIP
    twi.start()
    twi.set.rx.addr((dev << 1) \/ 1)
    SEQ i = 0 FOR ((SIZE bs) - 1)
      twi.read.byte(TWI.ACK, bs[i])
    twi.read.byte(TWI.NACK, bs[(SIZE bs) - 1])
    twi.stop()
:

INLINE PROC clock.read.many (VAL INT addr, RESULT []BYTE bs)
  twi.read.many (#68, BYTE.ADDR, #00, bs)
:

INLINE PROC eeprom.read.many (VAL INT addr, RESULT []BYTE bs)
  twi.read.many (#50, WORD.ADDR, #00, bs)
:

PROC current.time (CHAN SIGNAL s!, CHAN [3]BYTE reading!)
  [3]BYTE hms:
  [3]BYTE b:
  #PRAGMA DEFINED b
  WHILE TRUE
    SEQ
      clock.read.many (#00, b)
      hms[0] := (((b[0] BITAND #F0) >> 4) * 10) + (b[0] BITAND #0F)
      hms[1] := (((b[1] BITAND #F0) >> 4) * 10) + (b[1] BITAND #0F)
      hms[2] := (((b[2] BITAND #30) >> 4) * 10) + (b[2] BITAND #0F)
      reading ! hms
      s ! SIGNAL
:

--{{{ PROC zero.clock (VAL BOOL reset)
-- Zeros the clock module. "Sets the time", if you prefer.
PROC zero.clock (VAL BOOL reset)
  IF
    reset
      SEQ i = 0 FOR 3
        clock.write (i, #00)
    TRUE
      SKIP
:
--}}}

PROC display (CHAN [3]BYTE time?, CHAN INT light?, temp.curr?, temp.prev?)
  [3]BYTE hms:
  INT lv, t.c, t.p:
  WHILE TRUE
    SEQ
      PAR
        time ? hms
        light ? lv
        temp.curr ? t.c
        temp.prev ? t.p
      serial.write.string (TX0, "T ")
      SEQ i = 2 FOR 3 STEP -1    
        SEQ
          serial.write.int (TX0, (INT hms[i]))
          serial.write.string (TX0, " ")
      serial.write.string (TX0, " L ")
      serial.write.int (TX0, lv)
      serial.write.string (TX0, " TC ")
      serial.write.int(TX0, t.c)
      serial.write.string (TX0, " TP ")
      serial.write.int(TX0, t.p)
      serial.write.string (TX0, "*n")
:

--{{{ PROC signal.delta (CHAN SIGNAL s?, s1!, s2!)
-- Splits a signal into two.
PROC signal.delta (CHAN SIGNAL s?, s1!, s2!)
  WHILE TRUE
    SEQ
      s ? SIGNAL
      PAR
        s1 ! SIGNAL
        s2 ! SIGNAL
:
--}}}

--{{{ PROC convert.temp (CHAN INT in?, out!)
-- Converts a raw ADC reading to degrees Celcius.
-- Could use a more elegant solution within the bounds
-- of a 16-bit INT. Cheated and used 32 bits.
PROC convert.temp (CHAN INT in?, out!)
  WHILE TRUE
    INT v:
    INT32 lv:
    SEQ
      in ? v
      lv := (INT32 v)
      lv := (lv * 250) / 1024
      out ! (INT lv)
:
--}}}

PROC init.EEPROM.addr (VAL BOOL reset)
  SEQ
    IF
      reset
        SEQ
          serial.write.string (TX0, "EEPROM... ")
          -- Use #00, #01 as the address storage.
          -- Data should begin at #0002.
          eeprom.write (#00, #00) -- MSB
          eeprom.write (#01, #02) -- LSB
          serial.write.string (TX0, "reset.*n")
      TRUE
        SKIP
:

PROC store (CHAN INT t.in?, t.curr!, t.prev!)
  WHILE TRUE
    INT temp:
    INT addr, next.addr:
    BYTE nibble, stored:
    SEQ
      t.in ? temp
      -- Get the addr of the prev temperature
      -- and calc. the addr for the next one.
      eeprom.read (#00, nibble)
      addr := (INT nibble) << 8
      eeprom.read (#01, nibble)
      addr := (addr BITOR (INT nibble))
      next.addr := addr + 1

      -- Read in the stored temp
      -- WARNING WARNING WARNING
      -- We store BYTEs, because the temperature
      -- should never exceed the value of a BYTE.
      eeprom.read(addr, stored)
      -- Store the current temperature
      eeprom.write(next.addr, (BYTE temp))
      -- And store the next address
      eeprom.write(0, (BYTE (next.addr >> 8)))
      eeprom.write(1, (BYTE (next.addr BITAND #FF)))

      PAR
        t.curr ! (INT temp)
        t.prev ! (INT stored)
:

PROC display.last.n.readings (VAL INT n)
  INT addr:
  BYTE nibble:
  SEQ
    eeprom.read (#00, nibble)
    addr := (INT nibble) << 8
    eeprom.read (#01, nibble)
    addr := (addr BITOR (INT nibble))
    SEQ i = 0 FOR n
      IF
        (addr - i) > 1
          BYTE reading:
          SEQ
            eeprom.read(addr - i, reading)
            serial.write.int (TX0, n - i)
            serial.write.string (TX0, " ")
            serial.write.int (TX0, (INT reading))
            serial.write.string (TX0, "*n")
        TRUE
          SKIP
:

VAL BOOL FULL.RESET IS FALSE:    
PROC main ()
  SEQ
    serial.setup (TX0, 57600)
    zero.clock (FULL.RESET)
 
    display.last.n.readings (10)

    CHAN SIGNAL s, s1, s2:
    CHAN [3]BYTE time:
    CHAN INT light, temp.raw, temp.conv, temp.current, temp.prev:
    CHAN EEPROM e:
    CHAN BYTE e.resp:
    PAR
      eeprom.24lc256 (e?, e.resp!)
      current.time (s!, time!)
      signal.delta (s?, s1!, s2!)
      adc (A0, VCC, s1?, light!)
      adc (A1, VCC, s2?, temp.raw!)
      convert.temp (temp.raw?, temp.conv!)
      store (e!, e.resp?, temp.conv?, temp.current!, temp.prev!)
      display (time?, light?, temp.current?, temp.prev?)
:      
 
