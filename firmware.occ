#INCLUDE "plumbing.module"
#INCLUDE "eeprom.24LC256.module"
#INCLUDE "twi3.module"
#INCLUDE "pir.module"

VAL INT TEMP.SENSOR.PIN IS A1:
VAL INT LIGHT.SENSOR.PIN IS A0:

VAL BYTE INIT.READING   IS 'I':
VAL BYTE CLOCK.READING  IS 'C':
VAL BYTE MOTION.READING IS 'M':

DATA TYPE READING
  RECORD
    BYTE type:
    INT  temp:
    INT  light:
:

--{{{ PROC motion (SIGNAL s!)
-- Monitors the Modern Device PIR sensor.
-- Pin 5 is used to power the sensor.
-- Pin 2 is used to monitor the sensor.
-- A signal is generated on the channel 's'
-- whenever motion is detected.
PROC motion (CHAN SIGNAL s!)
  pir (5, 2, s!)
:
--}}}

--{{{ PROC n.minute.ticker (VAL INT minutes, CHAN SIGNAL in?, out!)
-- Expects a SIGNAL on the channel 'in' every minute.
-- Generates a SIGNAL on the channel 'out' every 'num.minutes'.
PROC n.minute.ticker (VAL INT num.minutes, CHAN SIGNAL in?, out!)
  INITIAL INT counter IS num.minutes:
  WHILE TRUE
    SEQ
      in ? SIGNAL
      counter := counter - 1
      IF
        counter <> 0
          SKIP
        TRUE
          SEQ
            out ! SIGNAL
            counter := num.minutes
:

PROC motion.throttle (CHAN SIGNAL motion?, reset?, out!)
  INITIAL BOOL IGNORING IS FALSE:
  WHILE TRUE
    ALT
      -- When the reset line fires, we can stop ignoring
      -- the motion sensor.
      reset ? SIGNAL
        IGNORING := FALSE
      -- If we are not ignoring the motion sensor, we should
      -- pass on the message that it fired, and then start
      -- ignoring it until the next reset comes in.
      NOT IGNORING & motion ? SIGNAL
        SEQ
          out ! SIGNAL
          IGNORING := TRUE
      -- We must be ignoring the motion sensor, so read in the 
      -- SIGNAL and then do nothing.
      IGNORING & motion ? SIGNAL
        serial.write.string (TX0, "IGNORED MOTION*n")        
:

PROC light.sensor (CHAN SIGNAL req?, CHAN INT resp!)
  adc (LIGHT.SENSOR.PIN, VCC, req?, resp!)
:

-- Output should end up in degrees C, and therefore
-- always within the range of a BYTE.
PROC convert.temp (CHAN INT in?, CHAN INT out!)
  WHILE TRUE
    INT32 lv:
    INT v:
    SEQ
      in ? v
      lv := (INT32 v)
      lv := (lv * 250) / 1024
      out ! (INT lv)
:

--}}}

PROC temp.sensor (CHAN SIGNAL req?, CHAN INT resp!)
  CHAN INT raw:
  PAR
    adc (TEMP.SENSOR.PIN, VCC, req?, raw!)
    convert.temp (raw?, resp!)
: 

PROC init.reading (CHAN SIGNAL s!)
  s ! SIGNAL
:

PROC do.reading (CHAN SIGNAL init?, motion?, clock?,
                 CHAN READING out!)
  CHAN SIGNAL light.req, temp.req:
  CHAN INT light.resp, temp.resp:
  PAR
    light.sensor (light.req?, light.resp!)
    temp.sensor (temp.req?, temp.resp!)
    WHILE TRUE
      READING r:
      SEQ
        -- Who asked for a reading?
        ALT
          init ? SIGNAL
            r[type] := INIT.READING
          motion ? SIGNAL
            r[type] := MOTION.READING
          clock ? SIGNAL
            r[type] := CLOCK.READING
        -- Get the light level
        light.req ! SIGNAL
        light.resp ? r[light]
        -- Get the temperature
        temp.req  ! SIGNAL
        temp.resp  ? r[temp]
        -- Send the data out
        out ! r
:

PROC display (CHAN READING data?)
  WHILE TRUE
    READING r:
    SEQ
      data ? r
      serial.write.string (TX0, [r[type]])
      serial.write.string (TX0, ": L[")
      serial.write.int    (TX0, r[light])
      serial.write.string (TX0, "] T[")
      serial.write.int    (TX0, r[temp])
      serial.write.string (TX0, "]*n")
:

PROC signal.delta (CHAN SIGNAL in?, o1!, o2!)
  WHILE TRUE
    SEQ
      in ? SIGNAL
      PAR
        o1 ! SIGNAL
        o2 ! SIGNAL
:

PROC bogo.clock (CHAN SIGNAL s!)
  WHILE TRUE
    SEQ
      delay (2000)
      s ! SIGNAL
:

PROC main ()
  CHAN SIGNAL tick, motion.tick, clock.tick:
  CHAN SIGNAL read.init, read.clock:
  CHAN SIGNAL movement, motion.ok, read.movement:
  CHAN READING data:
  PAR
    bogo.clock (tick!) 
    signal.delta (tick?, motion.tick!, clock.tick!)
    n.minute.ticker (5, motion.tick?, motion.ok!)
    n.minute.ticker (10, clock.tick?, read.clock!)
    
    init.reading (read.init!)
    
    motion (movement!)
    motion.throttle (movement?, motion.ok?, read.movement!)
    
    do.reading (read.init?, read.movement?, read.clock?, data!)
    
    display (data?)
    
:
